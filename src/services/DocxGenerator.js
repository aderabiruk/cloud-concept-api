import fs from 'fs'
import _ from 'lodash'
import path from 'path'
import { EventEmitter } from 'events'
import MailComposer from 'nodemailer/lib/mail-composer'

import config from '../config'
import XmlHelper from '../helpers/utils/xml'
import ZipHelper from '../helpers/utils/zip'
import EmailHelper from '../helpers/utils/ses'
import DocXHelper from '../helpers/utils/docx'

const emitter = new EventEmitter()
emitter.on('start', async ({ email, template, board }) => {
  // Convert DocX to Zip File
  const extension = path.extname(template)
  const zipFile = template.replace(extension, '.zip')
  fs.renameSync(template, zipFile)
  
  // Extract Zip File
  const zipFolder = zipFile.replace('.zip', '')
  await ZipHelper.extract(zipFile, zipFolder)

  // Prepare DocX
  const documentXml = `${zipFolder}/word/document.xml`
  const jsonContent = XmlHelper.xml2js(fs.readFileSync(documentXml).toString())
  
  const position = findTemplateElement(jsonContent, '<<table>>')
  console.log('Position of Template: ', position)
  if (position.p > -1) {
    const { columns, items } = board
    const table = await DocXHelper.generateDocxTableInJSON(
      zipFolder,
      columns.slice(0, 5),
      items.map(item => ({
        ...item,
        column_values: item.column_values.slice(0, 4)
      }))
    )
    _.set(jsonContent, `elements[${position.d}].elements[${position.b}].elements[${position.p}]`, table)
  }
  // fs.writeFileSync('xml.json', JSON.stringify(jsonContent))
  const xmlContent = XmlHelper.js2xml(jsonContent)
  fs.writeFileSync(documentXml, xmlContent)

  // Generate Zip File
  const basename = template.replace(extension, '')
  const outputZipFile = `${basename}-output.zip`
  await ZipHelper.zip(zipFolder, outputZipFile)
  
  // Convert Zip File to DocX
  const outputDocxFile = `${basename}-output.docx`
  fs.renameSync(outputZipFile, outputDocxFile)

  // Send Email
  const mailContent = new MailComposer({
    from: config.EMAIL_FROM,
    to: email,
    subject: 'BoardToWord',
    text: 'As per your request, a document has been generated by BoardToWord and attached below.',
    attachments: [
      {
        filename: 'output.docx',
        content: fs.createReadStream(outputDocxFile)
      }
    ]
  })
  await EmailHelper.sendRawEmail({ Data: (await mailContent.compile().build()).toString() })
})

function findTemplateElement (payload, text) {
  const position = {
    d: -1,
    b: -1,
    p: -1,
    r: -1,
    t: -1
  }

  const elements = payload?.elements || []
  for (let d = 0; d < elements.length; d++) {
    const element = elements[d]
    if (element.name !== 'w:document') {
      continue
    }

    const dElements = element?.elements || []
    for (let b = 0; b < dElements.length; b++) {
      const dElement = dElements[d]
      if (dElement.name !== 'w:body') {
        continue
      }

      const bElements = dElement?.elements || []
      for (let p = 0; p < bElements.length; p++) {
        const bElement = bElements[p]
        if (bElement.name !== 'w:p') {
          continue
        }
    
        const pElements = bElement?.elements || []
        for (let r = 0; r < pElements.length; r++) {
          const pElement = pElements[r]
          if (pElement.name !== 'w:r') {
            continue
          }
    
          const rElements = pElement?.elements || []
          for (let t = 0; t < rElements.length; t++) {
            const rElement = rElements[t]
            if (rElement.name !== 'w:t') {
              continue
            }
    
            const textItem = (rElement?.elements || []).find(item => item.type === 'text')
            if (_.toString(textItem.text) === _.toString(text)) {
              position.d = d
              position.b = b
              position.p = p
              position.r = r
              position.t = t
            }
          }
        }
      }
    }
  }
  return position
}

async function start(email, template, board) {
  console.log(`[Processing Template]: ${JSON.stringify(template, board )}`)
  emitter.emit('start', { email, template, board })
}

export default {
  start
}
